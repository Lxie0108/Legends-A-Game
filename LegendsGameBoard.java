
import java.util.Random;

/**
 * 
 * This is like the map of the game. It is generated by a given width and height.
 * It contains width*height number of cells. And it has (randomly assigned) 20% non-accessible cells, 30% markets and 50% common cells. 
 * It also sets the spawn point of the player and check if player's nextMove is valid.
 */

public class LegendsGameBoard extends GameBoard{
	private LegendsGameBoardCell[][] cells;
	private Marker playerMarker;
	private Marker prevMarker;
	private int width;
	private int height;
	private int curRowHero;
	private int curColHero;
	private int nextRowHero;
	private int nextColHero;
	
	public LegendsGameBoard(int width, int height) {
		this.width = width;
		this.height = height;
		initializeHeroMarker();
		generateNewBoard();
		setHeroSpawnPoint();
		
	}
	
	public void initializeHeroMarker() {
		playerMarker = new PlayerMarker();
	}
	
	public void generateNewBoard() {
		cells = new LegendsGameBoardCell[height][width];
		Random rand1 = new Random();
		Random rand2 = new Random();
		int totalcellNum = height*width;
		int inaccessibleNum = (int) (totalcellNum*0.2);//total number of inaccessible cells
		int marketCellNum = (int)(totalcellNum*0.3);//total number of market cells.
		int countInaccessible = 0;//count current inaccessible cell in the board
		int countMarket = 0;//count current market cell in the board.
		while(countInaccessible!=inaccessibleNum) {//fill the inaccessible cells first
			int r = rand1.nextInt(height);
			int c = rand2.nextInt(width);
			if(cells[r][c]==null) {
				cells[r][c] = new InaccessibleCell();
				countInaccessible++;
			}
		}
		while(countMarket != marketCellNum) {//fill the market cells
			int r = rand1.nextInt(height);
			int c = rand2.nextInt(width);
			if(cells[r][c]==null) {
				cells[r][c] = new MarketCell();
				countMarket++;
			}
		}
		for (int row = 0; row < height; row++) {//rest 50% will be common cell.
			for (int col = 0; col < width; col++) {
				if(cells[row][col] == null) {
					cells[row][col] = new CommonCell();
				}
			}
		}
	}
	
	public void setHeroSpawnPoint(){
		boolean found = false;
		for(int r = 0; r<height; r++) {
			for(int c = 0; c<width; c++) {
				if(cells[r][c].getMarker().getSymbol().equals(" ")) {//hero will spawn at the first common cell.
					updateHeroLoc(r,c);
					found = true;
					break;
				}	
			}
			if(found == true)
				break;
		}
	}
	
	public void setHeroLoc(int row, int col) {
		curRowHero = row;
		curColHero = col;
	}
	
	public void placeHeroMarker(int row, int col) {
		prevMarker = cells[row][col].getMarker();
		cells[row][col].setMarker(playerMarker);
	}
	
	public void updateHeroLoc(int row, int col) {
		setHeroLoc(row,col);
		placeHeroMarker(row,col);
	}
	
	public int checkCellType() {
		if(prevMarker.getSymbol().equals(" ")) {//common cell
			return 1;
		} if(prevMarker.getSymbol().equals("M")) {//market cell
			return 2;
		}
		return 0;
	}
	
	
	public int getHeroRow() {
		return curRowHero;
	}
	
	public int getHeroCol() {
		return curColHero;
	}
	
	public void setNextMove(int r, int c) {
		nextRowHero = r;
		nextColHero = c;
	}
	
	public boolean checkValidMove(int r, int c) {
		if(r>height||c>width||r<0||c<0) {//out of bound
			return false;
		}
		if(cells[r][c].getMarker().getSymbol().equals("&")) {
			return false;
		}
		return true;
	}
	
	public void restorePrevMarker(int r, int c) {
		cells[r][c].setMarker(prevMarker);
	}
	
	
	public void printBoard() {
		String str = "+--";
		char finisher = '+';
		String repeated = str.repeat(width);
		String rowBorder  = repeated+finisher;
		System.out.println(rowBorder);
		for (int row = 0; row < height; row++) {
			for (int col = 0; col < width; col++) {
				System.out.print("|" + cells[row][col].getMarker().getSymbol() + " ");
				if(col == width -1)
					System.out.print("|");
			}
			System.out.println();
			System.out.println(rowBorder);
		}
		System.out.println("M: market, &: inaccessible, X: current Location");
		System.out.println();
	}
}
